# Phunky Python 2 - 115 Points
#### sa1tfi5h's writeup

给了这么一份python代码
```python
import operator
jkx = 0 # REDACTED
pork = (((12 * jkx) + 44) / 4) - (2 * jkx) - 12
jkx = jkx * pork
pp = filter(lambda g: not any(g % u == 0 for u in range(2, g)), range(2, 10000))
b = reduce(operator.mul, (pp[i] ** int(str(jkx)[i]) for i in range(len(str(jkx))))) 
numbequalto = 298142533459972353125216208611896260313759854634379454017626913019869030523755628601926829163490056136759291154170246269588079406415640897289723163043052735571403370823999085880254558960787830191426580931166730005416850884124181616949102806794078012758190650585958197054633549146371576221689963259346156534026838740762695201862923852711351603315111735215388452000
print (b == numbequalto)
```

首先看看这个`pp`，一下子看不懂的话，直接放到shell里面跑一下就能知道这是一个素数列表，然后就能知道`b`是这个素数列表从小到大的`jkx`数位上的数次幂乘在一起，所以只需要用素数表去除一下这个很大很大的数，存下每次的次数还得注意零次幂，存下来的连在一起就是那个`jkx = jkx * pork`之后的`jkx`的值了

	jkx = 55394379648894917577198360684718697256

然后再往上推，化简是`pork = jkx - 1`，那么就是个一元二次方程了，但是直接用python原生地算会出问题，拿到[WolframAlpha](https://www.wolframalpha.com/)上面一跑，就能出来了

	7442740063235778328

比赛结束后看别的队的时候才发现这个代码文件跟当时下载的不一样orz
